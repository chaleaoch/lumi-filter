{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to lumi-filter","text":"<p>lumi-filter is a library for filtering data using a model-based approach.</p>"},{"location":"api/backend/","title":"Backend","text":""},{"location":"api/backend/#lumi_filter.backend","title":"<code>lumi_filter.backend</code>","text":"<p>Backend implementations for filtering and ordering data.</p> <p>This module provides backend classes for different data sources: - PeeweeBackend: For Peewee ORM queries - IterableBackend: For Python iterable data structures</p> <p>Both backends support various lookup expressions and maintain consistent interfaces for filtering and ordering operations.</p>"},{"location":"api/backend/#lumi_filter.backend.IterableBackend","title":"<code>IterableBackend</code>","text":"<p>Backend for filtering and ordering iterable data.</p> <p>This backend provides functionality to apply filters and ordering to iterable data structures like lists, tuples, sets, and dictionaries. It supports nested field access using dot notation and various lookup expressions for flexible data filtering.</p> <p>The backend is designed to be permissive, returning True on errors during filtering to avoid breaking the filter chain when dealing with inconsistent data structures.</p> <p>Attributes:</p> Name Type Description <code>LOOKUP_EXPR_OPERATOR_MAP</code> <code>dict</code> <p>Mapping of lookup expressions to corresponding operator functions.</p> Source code in <code>lumi_filter/backend.py</code> <pre><code>class IterableBackend:\n    \"\"\"Backend for filtering and ordering iterable data.\n\n    This backend provides functionality to apply filters and ordering\n    to iterable data structures like lists, tuples, sets, and dictionaries.\n    It supports nested field access using dot notation and various lookup\n    expressions for flexible data filtering.\n\n    The backend is designed to be permissive, returning True on errors\n    during filtering to avoid breaking the filter chain when dealing\n    with inconsistent data structures.\n\n    Attributes:\n        LOOKUP_EXPR_OPERATOR_MAP (dict): Mapping of lookup expressions\n            to corresponding operator functions.\n    \"\"\"\n\n    LOOKUP_EXPR_OPERATOR_MAP = {\n        \"\": operator.eq,\n        \"!\": operator.ne,\n        \"gte\": operator.ge,\n        \"lte\": operator.le,\n        \"gt\": operator.gt,\n        \"lt\": operator.lt,\n        \"contains\": generic_like_operator,\n        \"icontains\": generic_ilike_operator,\n        \"in\": generic_in_operator,\n    }\n\n    @classmethod\n    def _get_nested_value(cls, item, key):\n        \"\"\"Get nested value from item using dot notation.\n\n        Extracts a value from a nested data structure using dot notation\n        for the key path. For example, 'user.profile.name' would access\n        item['user']['profile']['name'].\n\n        Args:\n            item: The item to extract value from (dict-like object).\n            key (str): The key path using dot notation (e.g., 'user.name').\n\n        Returns:\n            The nested value.\n\n        Raises:\n            KeyError: If any part of the key path doesn't exist.\n        \"\"\"\n        for k in key.split(\".\"):\n            item = item[k]\n        return item\n\n    @classmethod\n    def _match_item(cls, item, key, value, lookup_expr):\n        \"\"\"Check if item matches the filter criteria.\n\n        Evaluates whether an item satisfies the specified filter condition.\n        Uses the appropriate operator based on the lookup expression and\n        handles nested field access. Returns True on errors (KeyError, TypeError)\n        to maintain a permissive filtering approach.\n\n        Args:\n            item: The item to check (dict-like object).\n            key (str): The key to filter on (supports dot notation).\n            value: The value to match against.\n            lookup_expr (str): The lookup expression for matching (e.g., '', '!',\n                'gte', 'lte', 'gt', 'lt', 'contains', 'icontains', 'in').\n\n        Returns:\n            bool: True if item matches the criteria, True on error (permissive).\n        \"\"\"\n        try:\n            item_value = cls._get_nested_value(item, key)\n            operator_func = cls.LOOKUP_EXPR_OPERATOR_MAP[lookup_expr]\n            return operator_func(item_value, value)\n        except (KeyError, TypeError):\n            return True\n\n    @classmethod\n    def filter(cls, data, key, value, lookup_expr):\n        \"\"\"Filter the data based on criteria.\n\n        Filters an iterable data structure based on the specified criteria.\n        Preserves the original data type of the input (list, tuple, set) while\n        filtering the elements. For other iterable types, returns a filter object.\n\n        Args:\n            data (iterable): The iterable data to filter.\n            key (str): The key to filter on (supports dot notation for nested access).\n            value: The value to filter by.\n            lookup_expr (str): The lookup expression for filtering (e.g., '', '!',\n                'gte', 'lte', 'gt', 'lt', 'contains', 'icontains', 'in').\n\n        Returns:\n            The filtered iterable of the same type as input (or a filter object).\n        \"\"\"\n\n        ret = filter(\n            partial(cls._match_item, key=key, value=value, lookup_expr=lookup_expr),\n            data,\n        )\n        if isinstance(data, list):\n            return list(ret)\n        if isinstance(data, tuple):\n            return tuple(ret)\n        if isinstance(data, set):\n            return set(ret)\n        return ret\n\n    @classmethod\n    def order(cls, data, ordering):\n        \"\"\"Sort the data by multiple keys.\n\n        Args:\n            data (iterable): The iterable data to sort.\n            ordering (list): List of tuples containing (key, is_reverse) pairs\n                where key is the field name to sort by (supports dot notation)\n                and is_reverse is a boolean indicating reverse order.\n\n        Returns:\n            The sorted data of the same type as input.\n        \"\"\"\n        try:\n            for key, is_reverse in ordering[::-1]:\n                data = sorted(data, key=lambda x: cls._get_nested_value(x, key), reverse=is_reverse)\n        except (KeyError, TypeError):\n            logger.warning(\"Failed to sort by ordering: %s\", ordering)\n        finally:\n            return data\n</code></pre>"},{"location":"api/backend/#lumi_filter.backend.IterableBackend.filter","title":"<code>filter(data, key, value, lookup_expr)</code>  <code>classmethod</code>","text":"<p>Filter the data based on criteria.</p> <p>Filters an iterable data structure based on the specified criteria. Preserves the original data type of the input (list, tuple, set) while filtering the elements. For other iterable types, returns a filter object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>iterable</code> <p>The iterable data to filter.</p> required <code>key</code> <code>str</code> <p>The key to filter on (supports dot notation for nested access).</p> required <code>value</code> <p>The value to filter by.</p> required <code>lookup_expr</code> <code>str</code> <p>The lookup expression for filtering (e.g., '', '!', 'gte', 'lte', 'gt', 'lt', 'contains', 'icontains', 'in').</p> required <p>Returns:</p> Type Description <p>The filtered iterable of the same type as input (or a filter object).</p> Source code in <code>lumi_filter/backend.py</code> <pre><code>@classmethod\ndef filter(cls, data, key, value, lookup_expr):\n    \"\"\"Filter the data based on criteria.\n\n    Filters an iterable data structure based on the specified criteria.\n    Preserves the original data type of the input (list, tuple, set) while\n    filtering the elements. For other iterable types, returns a filter object.\n\n    Args:\n        data (iterable): The iterable data to filter.\n        key (str): The key to filter on (supports dot notation for nested access).\n        value: The value to filter by.\n        lookup_expr (str): The lookup expression for filtering (e.g., '', '!',\n            'gte', 'lte', 'gt', 'lt', 'contains', 'icontains', 'in').\n\n    Returns:\n        The filtered iterable of the same type as input (or a filter object).\n    \"\"\"\n\n    ret = filter(\n        partial(cls._match_item, key=key, value=value, lookup_expr=lookup_expr),\n        data,\n    )\n    if isinstance(data, list):\n        return list(ret)\n    if isinstance(data, tuple):\n        return tuple(ret)\n    if isinstance(data, set):\n        return set(ret)\n    return ret\n</code></pre>"},{"location":"api/backend/#lumi_filter.backend.IterableBackend.order","title":"<code>order(data, ordering)</code>  <code>classmethod</code>","text":"<p>Sort the data by multiple keys.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>iterable</code> <p>The iterable data to sort.</p> required <code>ordering</code> <code>list</code> <p>List of tuples containing (key, is_reverse) pairs where key is the field name to sort by (supports dot notation) and is_reverse is a boolean indicating reverse order.</p> required <p>Returns:</p> Type Description <p>The sorted data of the same type as input.</p> Source code in <code>lumi_filter/backend.py</code> <pre><code>@classmethod\ndef order(cls, data, ordering):\n    \"\"\"Sort the data by multiple keys.\n\n    Args:\n        data (iterable): The iterable data to sort.\n        ordering (list): List of tuples containing (key, is_reverse) pairs\n            where key is the field name to sort by (supports dot notation)\n            and is_reverse is a boolean indicating reverse order.\n\n    Returns:\n        The sorted data of the same type as input.\n    \"\"\"\n    try:\n        for key, is_reverse in ordering[::-1]:\n            data = sorted(data, key=lambda x: cls._get_nested_value(x, key), reverse=is_reverse)\n    except (KeyError, TypeError):\n        logger.warning(\"Failed to sort by ordering: %s\", ordering)\n    finally:\n        return data\n</code></pre>"},{"location":"api/backend/#lumi_filter.backend.PeeweeBackend","title":"<code>PeeweeBackend</code>","text":"<p>Backend for filtering and ordering Peewee queries.</p> <p>This backend provides functionality to apply filters and ordering to Peewee ORM queries in a consistent manner. It supports various lookup expressions including equality, comparison operators, and text search operations.</p> <p>The backend handles database-specific optimizations, such as using FTS (Full Text Search) syntax for SQLite databases when performing contains operations.</p> <p>Attributes:</p> Name Type Description <code>LOOKUP_EXPR_OPERATOR_MAP</code> <code>dict</code> <p>Mapping of lookup expressions to corresponding Peewee operators.</p> Source code in <code>lumi_filter/backend.py</code> <pre><code>class PeeweeBackend:\n    \"\"\"Backend for filtering and ordering Peewee queries.\n\n    This backend provides functionality to apply filters and ordering\n    to Peewee ORM queries in a consistent manner. It supports various\n    lookup expressions including equality, comparison operators, and\n    text search operations.\n\n    The backend handles database-specific optimizations, such as using\n    FTS (Full Text Search) syntax for SQLite databases when performing\n    contains operations.\n\n    Attributes:\n        LOOKUP_EXPR_OPERATOR_MAP (dict): Mapping of lookup expressions\n            to corresponding Peewee operators.\n    \"\"\"\n\n    LOOKUP_EXPR_OPERATOR_MAP = {\n        \"\": operator.eq,\n        \"!\": operator.ne,\n        \"gte\": operator.ge,\n        \"lte\": operator.le,\n        \"gt\": operator.gt,\n        \"lt\": operator.lt,\n        \"contains\": operator.mod,\n        \"icontains\": operator.pow,\n        \"in\": operator.lshift,\n    }\n\n    def __init__(self):\n        \"\"\"Initialize the PeeweeBackend.\n\n        The backend is stateless and doesn't require any configuration.\n        All methods are class methods that operate on provided queries.\n        \"\"\"\n        pass\n\n    @classmethod\n    def filter(cls, query, peewee_field, value, lookup_expr):\n        \"\"\"Apply filter to the query.\n\n        Applies a filter condition to the Peewee query based on the provided\n        field, value, and lookup expression. Handles special cases for text\n        search operations, adjusting the value format for different database\n        backends (SQLite uses FTS syntax with asterisks, others use SQL LIKE\n        with percent signs).\n\n        Args:\n            query (peewee.Query): The Peewee query to filter.\n            peewee_field (peewee.Field): The Peewee field to filter on.\n            value: The value to filter by.\n            lookup_expr (str): The lookup expression for filtering (e.g., '', '!',\n                'gte', 'lte', 'gt', 'lt', 'contains', 'icontains', 'in').\n\n        Returns:\n            peewee.Query: Filtered query with the condition applied.\n\n        Raises:\n            TypeError: If peewee_field is not a Peewee Field instance.\n        \"\"\"\n        if lookup_expr == \"contains\":\n            if isinstance(query.model._meta.database, peewee.SqliteDatabase) or (\n                isinstance(query.model._meta.database, peewee.Proxy)\n                and isinstance(query.model._meta.database.obj, peewee.SqliteDatabase)\n            ):\n                value = f\"*{value}*\"\n            else:\n                value = f\"%{value}%\"\n        elif lookup_expr == \"icontains\":\n            value = f\"%{value}%\"\n\n        if not isinstance(peewee_field, peewee.Field):\n            raise TypeError(f\"Expected peewee.Field, got {type(peewee_field)}\")\n\n        operator_func = cls.LOOKUP_EXPR_OPERATOR_MAP[lookup_expr]\n        return query.where(operator_func(peewee_field, value))\n\n    @classmethod\n    def order(cls, query, ordering):\n        \"\"\"Apply ordering to the query.\n\n        Args:\n            query: The Peewee query to order.\n            ordering: List of tuples containing (field, is_negative) pairs\n                where field is the Peewee field to order by and\n                is_negative is a boolean indicating descending order.\n\n        Returns:\n            peewee.Query: Ordered query.\n        \"\"\"\n        order_fields = []\n        for field, is_negative in ordering:\n            order_fields.append(field.desc() if is_negative else field.asc())\n        return query.order_by(*order_fields)\n</code></pre>"},{"location":"api/backend/#lumi_filter.backend.PeeweeBackend.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the PeeweeBackend.</p> <p>The backend is stateless and doesn't require any configuration. All methods are class methods that operate on provided queries.</p> Source code in <code>lumi_filter/backend.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the PeeweeBackend.\n\n    The backend is stateless and doesn't require any configuration.\n    All methods are class methods that operate on provided queries.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/backend/#lumi_filter.backend.PeeweeBackend.filter","title":"<code>filter(query, peewee_field, value, lookup_expr)</code>  <code>classmethod</code>","text":"<p>Apply filter to the query.</p> <p>Applies a filter condition to the Peewee query based on the provided field, value, and lookup expression. Handles special cases for text search operations, adjusting the value format for different database backends (SQLite uses FTS syntax with asterisks, others use SQL LIKE with percent signs).</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Query</code> <p>The Peewee query to filter.</p> required <code>peewee_field</code> <code>Field</code> <p>The Peewee field to filter on.</p> required <code>value</code> <p>The value to filter by.</p> required <code>lookup_expr</code> <code>str</code> <p>The lookup expression for filtering (e.g., '', '!', 'gte', 'lte', 'gt', 'lt', 'contains', 'icontains', 'in').</p> required <p>Returns:</p> Type Description <p>peewee.Query: Filtered query with the condition applied.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If peewee_field is not a Peewee Field instance.</p> Source code in <code>lumi_filter/backend.py</code> <pre><code>@classmethod\ndef filter(cls, query, peewee_field, value, lookup_expr):\n    \"\"\"Apply filter to the query.\n\n    Applies a filter condition to the Peewee query based on the provided\n    field, value, and lookup expression. Handles special cases for text\n    search operations, adjusting the value format for different database\n    backends (SQLite uses FTS syntax with asterisks, others use SQL LIKE\n    with percent signs).\n\n    Args:\n        query (peewee.Query): The Peewee query to filter.\n        peewee_field (peewee.Field): The Peewee field to filter on.\n        value: The value to filter by.\n        lookup_expr (str): The lookup expression for filtering (e.g., '', '!',\n            'gte', 'lte', 'gt', 'lt', 'contains', 'icontains', 'in').\n\n    Returns:\n        peewee.Query: Filtered query with the condition applied.\n\n    Raises:\n        TypeError: If peewee_field is not a Peewee Field instance.\n    \"\"\"\n    if lookup_expr == \"contains\":\n        if isinstance(query.model._meta.database, peewee.SqliteDatabase) or (\n            isinstance(query.model._meta.database, peewee.Proxy)\n            and isinstance(query.model._meta.database.obj, peewee.SqliteDatabase)\n        ):\n            value = f\"*{value}*\"\n        else:\n            value = f\"%{value}%\"\n    elif lookup_expr == \"icontains\":\n        value = f\"%{value}%\"\n\n    if not isinstance(peewee_field, peewee.Field):\n        raise TypeError(f\"Expected peewee.Field, got {type(peewee_field)}\")\n\n    operator_func = cls.LOOKUP_EXPR_OPERATOR_MAP[lookup_expr]\n    return query.where(operator_func(peewee_field, value))\n</code></pre>"},{"location":"api/backend/#lumi_filter.backend.PeeweeBackend.order","title":"<code>order(query, ordering)</code>  <code>classmethod</code>","text":"<p>Apply ordering to the query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <p>The Peewee query to order.</p> required <code>ordering</code> <p>List of tuples containing (field, is_negative) pairs where field is the Peewee field to order by and is_negative is a boolean indicating descending order.</p> required <p>Returns:</p> Type Description <p>peewee.Query: Ordered query.</p> Source code in <code>lumi_filter/backend.py</code> <pre><code>@classmethod\ndef order(cls, query, ordering):\n    \"\"\"Apply ordering to the query.\n\n    Args:\n        query: The Peewee query to order.\n        ordering: List of tuples containing (field, is_negative) pairs\n            where field is the Peewee field to order by and\n            is_negative is a boolean indicating descending order.\n\n    Returns:\n        peewee.Query: Ordered query.\n    \"\"\"\n    order_fields = []\n    for field, is_negative in ordering:\n        order_fields.append(field.desc() if is_negative else field.asc())\n    return query.order_by(*order_fields)\n</code></pre>"},{"location":"api/field/","title":"Field","text":""},{"location":"api/field/#lumi_filter.field","title":"<code>lumi_filter.field</code>","text":""},{"location":"api/field/#lumi_filter.field.BooleanField","title":"<code>BooleanField</code>","text":"<p>               Bases: <code>FilterField</code></p> <p>Boolean field filter for true/false filtering operations.</p> <p>Handles parsing and validation of boolean values for filtering operations. Accepts various string representations of boolean values and converts them to proper Python boolean types. Supports flexible input formats commonly used in web applications and configuration files.</p> <p>Attributes:</p> Name Type Description <code>SUPPORTED_LOOKUP_EXPR</code> <code>frozenset</code> <p>Supported lookup expressions: - \"\" (empty): Exact equality (only supports exact boolean matching)</p> Source code in <code>lumi_filter/field.py</code> <pre><code>class BooleanField(FilterField):\n    \"\"\"Boolean field filter for true/false filtering operations.\n\n    Handles parsing and validation of boolean values for filtering operations.\n    Accepts various string representations of boolean values and converts them\n    to proper Python boolean types. Supports flexible input formats commonly\n    used in web applications and configuration files.\n\n    Attributes:\n        SUPPORTED_LOOKUP_EXPR (frozenset): Supported lookup expressions:\n            - \"\" (empty): Exact equality (only supports exact boolean matching)\n    \"\"\"\n\n    SUPPORTED_LOOKUP_EXPR = frozenset({\"\"})\n\n    def parse_value(self, value):\n        \"\"\"Parse various representations to boolean.\n\n        Converts string and boolean inputs to Python boolean values.\n        Accepts multiple common representations of true/false values.\n\n        Args:\n            value: Input value to convert to boolean. Can be bool, string,\n                or other types.\n\n        Returns:\n            tuple: A tuple containing (parsed_value, is_valid) where:\n                - parsed_value (bool or None): The boolean value if conversion\n                  succeeds, None if it fails\n                - is_valid (bool): True if conversion succeeds, False otherwise\n\n        Note:\n            Accepted true values: 'true', '1', 'yes', 'on' (case-insensitive)\n            Accepted false values: 'false', '0', 'no', 'off' (case-insensitive)\n\n        Examples:\n            &gt;&gt;&gt; field = BooleanField()\n            &gt;&gt;&gt; field.parse_value(\"true\")\n            (True, True)\n            &gt;&gt;&gt; field.parse_value(\"0\")\n            (False, True)\n            &gt;&gt;&gt; field.parse_value(\"invalid\")\n            (None, False)\n        \"\"\"\n        if isinstance(value, bool):\n            return value, True\n        if isinstance(value, str):\n            lower_value = value.lower()\n            if lower_value in (\"true\", \"1\", \"yes\", \"on\"):\n                return True, True\n            elif lower_value in (\"false\", \"0\", \"no\", \"off\"):\n                return False, True\n        return None, False\n</code></pre>"},{"location":"api/field/#lumi_filter.field.BooleanField.parse_value","title":"<code>parse_value(value)</code>","text":"<p>Parse various representations to boolean.</p> <p>Converts string and boolean inputs to Python boolean values. Accepts multiple common representations of true/false values.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>Input value to convert to boolean. Can be bool, string, or other types.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing (parsed_value, is_valid) where: - parsed_value (bool or None): The boolean value if conversion   succeeds, None if it fails - is_valid (bool): True if conversion succeeds, False otherwise</p> Note <p>Accepted true values: 'true', '1', 'yes', 'on' (case-insensitive) Accepted false values: 'false', '0', 'no', 'off' (case-insensitive)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field = BooleanField()\n&gt;&gt;&gt; field.parse_value(\"true\")\n(True, True)\n&gt;&gt;&gt; field.parse_value(\"0\")\n(False, True)\n&gt;&gt;&gt; field.parse_value(\"invalid\")\n(None, False)\n</code></pre> Source code in <code>lumi_filter/field.py</code> <pre><code>def parse_value(self, value):\n    \"\"\"Parse various representations to boolean.\n\n    Converts string and boolean inputs to Python boolean values.\n    Accepts multiple common representations of true/false values.\n\n    Args:\n        value: Input value to convert to boolean. Can be bool, string,\n            or other types.\n\n    Returns:\n        tuple: A tuple containing (parsed_value, is_valid) where:\n            - parsed_value (bool or None): The boolean value if conversion\n              succeeds, None if it fails\n            - is_valid (bool): True if conversion succeeds, False otherwise\n\n    Note:\n        Accepted true values: 'true', '1', 'yes', 'on' (case-insensitive)\n        Accepted false values: 'false', '0', 'no', 'off' (case-insensitive)\n\n    Examples:\n        &gt;&gt;&gt; field = BooleanField()\n        &gt;&gt;&gt; field.parse_value(\"true\")\n        (True, True)\n        &gt;&gt;&gt; field.parse_value(\"0\")\n        (False, True)\n        &gt;&gt;&gt; field.parse_value(\"invalid\")\n        (None, False)\n    \"\"\"\n    if isinstance(value, bool):\n        return value, True\n    if isinstance(value, str):\n        lower_value = value.lower()\n        if lower_value in (\"true\", \"1\", \"yes\", \"on\"):\n            return True, True\n        elif lower_value in (\"false\", \"0\", \"no\", \"off\"):\n            return False, True\n    return None, False\n</code></pre>"},{"location":"api/field/#lumi_filter.field.DateField","title":"<code>DateField</code>","text":"<p>               Bases: <code>FilterField</code></p> <p>Date field filter for date-only filtering operations.</p> <p>Handles parsing and validation of date values for filtering operations. Accepts both datetime.date objects and ISO format date strings. Provides date-based comparisons without time components.</p> <p>Attributes:</p> Name Type Description <code>SUPPORTED_LOOKUP_EXPR</code> <code>frozenset</code> <p>Supported lookup expressions: - \"\" (empty): Exact date equality - \"!\": Not equal - \"gt\": After date (greater than) - \"lt\": Before date (less than) - \"gte\": On or after date (greater than or equal) - \"lte\": On or before date (less than or equal) - \"in\": Date list membership</p> Source code in <code>lumi_filter/field.py</code> <pre><code>class DateField(FilterField):\n    \"\"\"Date field filter for date-only filtering operations.\n\n    Handles parsing and validation of date values for filtering operations.\n    Accepts both datetime.date objects and ISO format date strings. Provides\n    date-based comparisons without time components.\n\n    Attributes:\n        SUPPORTED_LOOKUP_EXPR (frozenset): Supported lookup expressions:\n            - \"\" (empty): Exact date equality\n            - \"!\": Not equal\n            - \"gt\": After date (greater than)\n            - \"lt\": Before date (less than)\n            - \"gte\": On or after date (greater than or equal)\n            - \"lte\": On or before date (less than or equal)\n            - \"in\": Date list membership\n    \"\"\"\n\n    SUPPORTED_LOOKUP_EXPR = frozenset({\"\", \"!\", \"gt\", \"lt\", \"gte\", \"lte\", \"in\"})\n\n    def parse_value(self, value):\n        \"\"\"Parse datetime.date objects or ISO date strings.\n\n        Converts input to datetime.date objects. Accepts existing date objects\n        or parses ISO format date strings (YYYY-MM-DD).\n\n        Args:\n            value: Input value to convert to date. Can be datetime.date object\n                or string in ISO format (YYYY-MM-DD).\n\n        Returns:\n            tuple: A tuple containing (parsed_value, is_valid) where:\n                - parsed_value (datetime.date or None): The date value if conversion\n                  succeeds, None if it fails\n                - is_valid (bool): True if conversion succeeds, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; field = DateField()\n            &gt;&gt;&gt; field.parse_value(\"2023-12-25\")\n            (datetime.date(2023, 12, 25), True)\n            &gt;&gt;&gt; field.parse_value(\"invalid-date\")\n            (None, False)\n        \"\"\"\n        if isinstance(value, datetime.date):\n            return value, True\n        try:\n            return datetime.datetime.strptime(value, \"%Y-%m-%d\").date(), True\n        except (ValueError, TypeError):\n            return None, False\n</code></pre>"},{"location":"api/field/#lumi_filter.field.DateField.parse_value","title":"<code>parse_value(value)</code>","text":"<p>Parse datetime.date objects or ISO date strings.</p> <p>Converts input to datetime.date objects. Accepts existing date objects or parses ISO format date strings (YYYY-MM-DD).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>Input value to convert to date. Can be datetime.date object or string in ISO format (YYYY-MM-DD).</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing (parsed_value, is_valid) where: - parsed_value (datetime.date or None): The date value if conversion   succeeds, None if it fails - is_valid (bool): True if conversion succeeds, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field = DateField()\n&gt;&gt;&gt; field.parse_value(\"2023-12-25\")\n(datetime.date(2023, 12, 25), True)\n&gt;&gt;&gt; field.parse_value(\"invalid-date\")\n(None, False)\n</code></pre> Source code in <code>lumi_filter/field.py</code> <pre><code>def parse_value(self, value):\n    \"\"\"Parse datetime.date objects or ISO date strings.\n\n    Converts input to datetime.date objects. Accepts existing date objects\n    or parses ISO format date strings (YYYY-MM-DD).\n\n    Args:\n        value: Input value to convert to date. Can be datetime.date object\n            or string in ISO format (YYYY-MM-DD).\n\n    Returns:\n        tuple: A tuple containing (parsed_value, is_valid) where:\n            - parsed_value (datetime.date or None): The date value if conversion\n              succeeds, None if it fails\n            - is_valid (bool): True if conversion succeeds, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; field = DateField()\n        &gt;&gt;&gt; field.parse_value(\"2023-12-25\")\n        (datetime.date(2023, 12, 25), True)\n        &gt;&gt;&gt; field.parse_value(\"invalid-date\")\n        (None, False)\n    \"\"\"\n    if isinstance(value, datetime.date):\n        return value, True\n    try:\n        return datetime.datetime.strptime(value, \"%Y-%m-%d\").date(), True\n    except (ValueError, TypeError):\n        return None, False\n</code></pre>"},{"location":"api/field/#lumi_filter.field.DateTimeField","title":"<code>DateTimeField</code>","text":"<p>               Bases: <code>FilterField</code></p> <p>DateTime field filter for date and time filtering operations.</p> <p>Handles parsing and validation of datetime values for filtering operations. Accepts both datetime.datetime objects and ISO format datetime strings. Provides timestamp-based comparisons including both date and time components.</p> <p>Attributes:</p> Name Type Description <code>SUPPORTED_LOOKUP_EXPR</code> <code>frozenset</code> <p>Supported lookup expressions: - \"\" (empty): Exact datetime equality - \"!\": Not equal - \"gt\": After datetime (greater than) - \"lt\": Before datetime (less than) - \"gte\": On or after datetime (greater than or equal) - \"lte\": On or before datetime (less than or equal) - \"in\": DateTime list membership</p> Source code in <code>lumi_filter/field.py</code> <pre><code>class DateTimeField(FilterField):\n    \"\"\"DateTime field filter for date and time filtering operations.\n\n    Handles parsing and validation of datetime values for filtering operations.\n    Accepts both datetime.datetime objects and ISO format datetime strings.\n    Provides timestamp-based comparisons including both date and time components.\n\n    Attributes:\n        SUPPORTED_LOOKUP_EXPR (frozenset): Supported lookup expressions:\n            - \"\" (empty): Exact datetime equality\n            - \"!\": Not equal\n            - \"gt\": After datetime (greater than)\n            - \"lt\": Before datetime (less than)\n            - \"gte\": On or after datetime (greater than or equal)\n            - \"lte\": On or before datetime (less than or equal)\n            - \"in\": DateTime list membership\n    \"\"\"\n\n    SUPPORTED_LOOKUP_EXPR = frozenset({\"\", \"!\", \"gt\", \"lt\", \"gte\", \"lte\", \"in\"})\n\n    def parse_value(self, value):\n        \"\"\"Parse datetime.datetime objects or ISO datetime strings.\n\n        Converts input to datetime.datetime objects. Accepts existing datetime objects\n        or parses ISO format datetime strings (YYYY-MM-DDTHH:MM:SS).\n\n        Args:\n            value: Input value to convert to datetime. Can be datetime.datetime object\n                or string in ISO format (YYYY-MM-DDTHH:MM:SS).\n\n        Returns:\n            tuple: A tuple containing (parsed_value, is_valid) where:\n                - parsed_value (datetime.datetime or None): The datetime value if\n                  conversion succeeds, None if it fails\n                - is_valid (bool): True if conversion succeeds, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; field = DateTimeField()\n            &gt;&gt;&gt; field.parse_value(\"2023-12-25T14:30:00\")\n            (datetime.datetime(2023, 12, 25, 14, 30), True)\n            &gt;&gt;&gt; field.parse_value(\"invalid-datetime\")\n            (None, False)\n        \"\"\"\n        if isinstance(value, datetime.datetime):\n            return value, True\n        try:\n            return datetime.datetime.strptime(value, \"%Y-%m-%dT%H:%M:%S\"), True\n        except (ValueError, TypeError):\n            return None, False\n</code></pre>"},{"location":"api/field/#lumi_filter.field.DateTimeField.parse_value","title":"<code>parse_value(value)</code>","text":"<p>Parse datetime.datetime objects or ISO datetime strings.</p> <p>Converts input to datetime.datetime objects. Accepts existing datetime objects or parses ISO format datetime strings (YYYY-MM-DDTHH:MM:SS).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>Input value to convert to datetime. Can be datetime.datetime object or string in ISO format (YYYY-MM-DDTHH:MM:SS).</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing (parsed_value, is_valid) where: - parsed_value (datetime.datetime or None): The datetime value if   conversion succeeds, None if it fails - is_valid (bool): True if conversion succeeds, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field = DateTimeField()\n&gt;&gt;&gt; field.parse_value(\"2023-12-25T14:30:00\")\n(datetime.datetime(2023, 12, 25, 14, 30), True)\n&gt;&gt;&gt; field.parse_value(\"invalid-datetime\")\n(None, False)\n</code></pre> Source code in <code>lumi_filter/field.py</code> <pre><code>def parse_value(self, value):\n    \"\"\"Parse datetime.datetime objects or ISO datetime strings.\n\n    Converts input to datetime.datetime objects. Accepts existing datetime objects\n    or parses ISO format datetime strings (YYYY-MM-DDTHH:MM:SS).\n\n    Args:\n        value: Input value to convert to datetime. Can be datetime.datetime object\n            or string in ISO format (YYYY-MM-DDTHH:MM:SS).\n\n    Returns:\n        tuple: A tuple containing (parsed_value, is_valid) where:\n            - parsed_value (datetime.datetime or None): The datetime value if\n              conversion succeeds, None if it fails\n            - is_valid (bool): True if conversion succeeds, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; field = DateTimeField()\n        &gt;&gt;&gt; field.parse_value(\"2023-12-25T14:30:00\")\n        (datetime.datetime(2023, 12, 25, 14, 30), True)\n        &gt;&gt;&gt; field.parse_value(\"invalid-datetime\")\n        (None, False)\n    \"\"\"\n    if isinstance(value, datetime.datetime):\n        return value, True\n    try:\n        return datetime.datetime.strptime(value, \"%Y-%m-%dT%H:%M:%S\"), True\n    except (ValueError, TypeError):\n        return None, False\n</code></pre>"},{"location":"api/field/#lumi_filter.field.DecimalField","title":"<code>DecimalField</code>","text":"<p>               Bases: <code>FilterField</code></p> <p>Decimal field filter for precise numeric filtering operations.</p> <p>Handles parsing and validation of decimal values for filtering operations. Provides precise decimal arithmetic suitable for financial calculations, scientific measurements, and other scenarios requiring exact decimal representation without floating-point precision issues.</p> <p>Attributes:</p> Name Type Description <code>SUPPORTED_LOOKUP_EXPR</code> <code>frozenset</code> <p>Supported lookup expressions: - \"\" (empty): Exact equality - \"!\": Not equal - \"gt\": Greater than - \"lt\": Less than - \"gte\": Greater than or equal - \"lte\": Less than or equal - \"in\": List membership</p> Source code in <code>lumi_filter/field.py</code> <pre><code>class DecimalField(FilterField):\n    \"\"\"Decimal field filter for precise numeric filtering operations.\n\n    Handles parsing and validation of decimal values for filtering operations.\n    Provides precise decimal arithmetic suitable for financial calculations,\n    scientific measurements, and other scenarios requiring exact decimal\n    representation without floating-point precision issues.\n\n    Attributes:\n        SUPPORTED_LOOKUP_EXPR (frozenset): Supported lookup expressions:\n            - \"\" (empty): Exact equality\n            - \"!\": Not equal\n            - \"gt\": Greater than\n            - \"lt\": Less than\n            - \"gte\": Greater than or equal\n            - \"lte\": Less than or equal\n            - \"in\": List membership\n    \"\"\"\n\n    SUPPORTED_LOOKUP_EXPR = frozenset({\"\", \"!\", \"gt\", \"lt\", \"gte\", \"lte\", \"in\"})\n\n    def parse_value(self, value):\n        \"\"\"Parse string or numeric input to Decimal.\n\n        Converts the input value to a decimal.Decimal object for precise\n        arithmetic operations.\n\n        Args:\n            value: Input value to convert to Decimal. Can be string, int,\n                float, or other numeric types.\n\n        Returns:\n            tuple: A tuple containing (parsed_value, is_valid) where:\n                - parsed_value (Decimal or None): The Decimal value if conversion\n                  succeeds, None if it fails\n                - is_valid (bool): True if conversion succeeds, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; field = DecimalField()\n            &gt;&gt;&gt; field.parse_value(\"123.45\")\n            (Decimal('123.45'), True)\n            &gt;&gt;&gt; field.parse_value(\"invalid\")\n            (None, False)\n        \"\"\"\n        try:\n            return decimal.Decimal(value), True\n        except (ValueError, TypeError, decimal.InvalidOperation):\n            return None, False\n</code></pre>"},{"location":"api/field/#lumi_filter.field.DecimalField.parse_value","title":"<code>parse_value(value)</code>","text":"<p>Parse string or numeric input to Decimal.</p> <p>Converts the input value to a decimal.Decimal object for precise arithmetic operations.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>Input value to convert to Decimal. Can be string, int, float, or other numeric types.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing (parsed_value, is_valid) where: - parsed_value (Decimal or None): The Decimal value if conversion   succeeds, None if it fails - is_valid (bool): True if conversion succeeds, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field = DecimalField()\n&gt;&gt;&gt; field.parse_value(\"123.45\")\n(Decimal('123.45'), True)\n&gt;&gt;&gt; field.parse_value(\"invalid\")\n(None, False)\n</code></pre> Source code in <code>lumi_filter/field.py</code> <pre><code>def parse_value(self, value):\n    \"\"\"Parse string or numeric input to Decimal.\n\n    Converts the input value to a decimal.Decimal object for precise\n    arithmetic operations.\n\n    Args:\n        value: Input value to convert to Decimal. Can be string, int,\n            float, or other numeric types.\n\n    Returns:\n        tuple: A tuple containing (parsed_value, is_valid) where:\n            - parsed_value (Decimal or None): The Decimal value if conversion\n              succeeds, None if it fails\n            - is_valid (bool): True if conversion succeeds, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; field = DecimalField()\n        &gt;&gt;&gt; field.parse_value(\"123.45\")\n        (Decimal('123.45'), True)\n        &gt;&gt;&gt; field.parse_value(\"invalid\")\n        (None, False)\n    \"\"\"\n    try:\n        return decimal.Decimal(value), True\n    except (ValueError, TypeError, decimal.InvalidOperation):\n        return None, False\n</code></pre>"},{"location":"api/field/#lumi_filter.field.FilterField","title":"<code>FilterField</code>","text":"<p>Base class for filter fields with common functionality.</p> <p>This class provides the foundation for all filter field types, handling basic parsing and validation operations. It defines the interface for field-specific value parsing and validation.</p> <p>Attributes:</p> Name Type Description <code>SUPPORTED_LOOKUP_EXPR</code> <code>frozenset</code> <p>Set of supported lookup expressions for filtering operations. Includes equality, negation, comparisons, containment checks, and list membership.</p> <code>request_arg_name</code> <code>str or None</code> <p>Name of the request argument to bind to. If None, uses the field name from the filter class.</p> <code>source</code> <code>str or None</code> <p>Source field or attribute name in the data model. If None, uses the field name from the filter class.</p> <p>Parameters:</p> Name Type Description Default <code>request_arg_name</code> <code>str</code> <p>Name of the request argument. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>Source field or attribute name. Defaults to None.</p> <code>None</code> Source code in <code>lumi_filter/field.py</code> <pre><code>class FilterField:\n    \"\"\"Base class for filter fields with common functionality.\n\n    This class provides the foundation for all filter field types,\n    handling basic parsing and validation operations. It defines the\n    interface for field-specific value parsing and validation.\n\n    Attributes:\n        SUPPORTED_LOOKUP_EXPR (frozenset): Set of supported lookup expressions\n            for filtering operations. Includes equality, negation, comparisons,\n            containment checks, and list membership.\n        request_arg_name (str or None): Name of the request argument to bind to.\n            If None, uses the field name from the filter class.\n        source (str or None): Source field or attribute name in the data model.\n            If None, uses the field name from the filter class.\n\n    Args:\n        request_arg_name (str, optional): Name of the request argument.\n            Defaults to None.\n        source (str, optional): Source field or attribute name.\n            Defaults to None.\n    \"\"\"\n\n    SUPPORTED_LOOKUP_EXPR = frozenset({\"\", \"!\", \"gt\", \"lt\", \"gte\", \"lte\", \"in\", \"contains\", \"icontains\"})\n\n    def __init__(self, request_arg_name=None, source=None):\n        self.request_arg_name = request_arg_name\n        self.source = source\n\n    def parse_value(self, value):\n        \"\"\"Parse and validate the input value.\n\n        This is the base implementation that accepts any value as valid.\n        Subclasses should override this method to provide type-specific\n        parsing and validation logic.\n\n        Args:\n            value: The input value to parse and validate.\n\n        Returns:\n            tuple: A tuple containing (parsed_value, is_valid) where:\n                - parsed_value: The parsed and potentially converted value\n                - is_valid (bool): True if the value is valid, False otherwise\n        \"\"\"\n        return value, True\n</code></pre>"},{"location":"api/field/#lumi_filter.field.FilterField.parse_value","title":"<code>parse_value(value)</code>","text":"<p>Parse and validate the input value.</p> <p>This is the base implementation that accepts any value as valid. Subclasses should override this method to provide type-specific parsing and validation logic.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The input value to parse and validate.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing (parsed_value, is_valid) where: - parsed_value: The parsed and potentially converted value - is_valid (bool): True if the value is valid, False otherwise</p> Source code in <code>lumi_filter/field.py</code> <pre><code>def parse_value(self, value):\n    \"\"\"Parse and validate the input value.\n\n    This is the base implementation that accepts any value as valid.\n    Subclasses should override this method to provide type-specific\n    parsing and validation logic.\n\n    Args:\n        value: The input value to parse and validate.\n\n    Returns:\n        tuple: A tuple containing (parsed_value, is_valid) where:\n            - parsed_value: The parsed and potentially converted value\n            - is_valid (bool): True if the value is valid, False otherwise\n    \"\"\"\n    return value, True\n</code></pre>"},{"location":"api/field/#lumi_filter.field.IntField","title":"<code>IntField</code>","text":"<p>               Bases: <code>FilterField</code></p> <p>Integer field filter for numeric filtering operations.</p> <p>Handles parsing and validation of integer values for filtering operations. Supports numerical comparison operations like equality, greater than, less than, and list membership. String representations of integers are automatically converted to int type.</p> <p>Attributes:</p> Name Type Description <code>SUPPORTED_LOOKUP_EXPR</code> <code>frozenset</code> <p>Supported lookup expressions: - \"\" (empty): Exact equality - \"!\": Not equal - \"gt\": Greater than - \"lt\": Less than - \"gte\": Greater than or equal - \"lte\": Less than or equal - \"in\": List membership</p> Source code in <code>lumi_filter/field.py</code> <pre><code>class IntField(FilterField):\n    \"\"\"Integer field filter for numeric filtering operations.\n\n    Handles parsing and validation of integer values for filtering operations.\n    Supports numerical comparison operations like equality, greater than,\n    less than, and list membership. String representations of integers\n    are automatically converted to int type.\n\n    Attributes:\n        SUPPORTED_LOOKUP_EXPR (frozenset): Supported lookup expressions:\n            - \"\" (empty): Exact equality\n            - \"!\": Not equal\n            - \"gt\": Greater than\n            - \"lt\": Less than\n            - \"gte\": Greater than or equal\n            - \"lte\": Less than or equal\n            - \"in\": List membership\n    \"\"\"\n\n    SUPPORTED_LOOKUP_EXPR = frozenset({\"\", \"!\", \"gt\", \"lt\", \"gte\", \"lte\", \"in\"})\n\n    def parse_value(self, value):\n        \"\"\"Parse string or numeric input to integer.\n\n        Attempts to convert the input value to an integer type.\n\n        Args:\n            value: Input value to convert to integer. Can be string, int,\n                or other numeric types.\n\n        Returns:\n            tuple: A tuple containing (parsed_value, is_valid) where:\n                - parsed_value (int or None): The integer value if conversion\n                  succeeds, None if it fails\n                - is_valid (bool): True if conversion succeeds, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; field = IntField()\n            &gt;&gt;&gt; field.parse_value(\"123\")\n            (123, True)\n            &gt;&gt;&gt; field.parse_value(\"invalid\")\n            (None, False)\n        \"\"\"\n        try:\n            return int(value), True\n        except (ValueError, TypeError):\n            return None, False\n</code></pre>"},{"location":"api/field/#lumi_filter.field.IntField.parse_value","title":"<code>parse_value(value)</code>","text":"<p>Parse string or numeric input to integer.</p> <p>Attempts to convert the input value to an integer type.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>Input value to convert to integer. Can be string, int, or other numeric types.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing (parsed_value, is_valid) where: - parsed_value (int or None): The integer value if conversion   succeeds, None if it fails - is_valid (bool): True if conversion succeeds, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; field = IntField()\n&gt;&gt;&gt; field.parse_value(\"123\")\n(123, True)\n&gt;&gt;&gt; field.parse_value(\"invalid\")\n(None, False)\n</code></pre> Source code in <code>lumi_filter/field.py</code> <pre><code>def parse_value(self, value):\n    \"\"\"Parse string or numeric input to integer.\n\n    Attempts to convert the input value to an integer type.\n\n    Args:\n        value: Input value to convert to integer. Can be string, int,\n            or other numeric types.\n\n    Returns:\n        tuple: A tuple containing (parsed_value, is_valid) where:\n            - parsed_value (int or None): The integer value if conversion\n              succeeds, None if it fails\n            - is_valid (bool): True if conversion succeeds, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; field = IntField()\n        &gt;&gt;&gt; field.parse_value(\"123\")\n        (123, True)\n        &gt;&gt;&gt; field.parse_value(\"invalid\")\n        (None, False)\n    \"\"\"\n    try:\n        return int(value), True\n    except (ValueError, TypeError):\n        return None, False\n</code></pre>"},{"location":"api/field/#lumi_filter.field.StrField","title":"<code>StrField</code>","text":"<p>               Bases: <code>FilterField</code></p> <p>String field filter for text-based filtering operations.</p> <p>Handles parsing and validation of string values for filtering operations. Supports comprehensive text matching operations including exact matches, case-sensitive and case-insensitive containment checks, comparisons, and list membership.</p> <p>Attributes:</p> Name Type Description <code>SUPPORTED_LOOKUP_EXPR</code> <code>frozenset</code> <p>Supported lookup expressions: - \"\" (empty): Exact equality (case-sensitive) - \"!\": Not equal - \"gt\": Greater than (lexicographical) - \"lt\": Less than (lexicographical) - \"gte\": Greater than or equal (lexicographical) - \"lte\": Less than or equal (lexicographical) - \"in\": List membership - \"contains\": Case-sensitive substring match - \"icontains\": Case-insensitive substring match</p> Source code in <code>lumi_filter/field.py</code> <pre><code>class StrField(FilterField):\n    \"\"\"String field filter for text-based filtering operations.\n\n    Handles parsing and validation of string values for filtering operations.\n    Supports comprehensive text matching operations including exact matches,\n    case-sensitive and case-insensitive containment checks, comparisons,\n    and list membership.\n\n    Attributes:\n        SUPPORTED_LOOKUP_EXPR (frozenset): Supported lookup expressions:\n            - \"\" (empty): Exact equality (case-sensitive)\n            - \"!\": Not equal\n            - \"gt\": Greater than (lexicographical)\n            - \"lt\": Less than (lexicographical)\n            - \"gte\": Greater than or equal (lexicographical)\n            - \"lte\": Less than or equal (lexicographical)\n            - \"in\": List membership\n            - \"contains\": Case-sensitive substring match\n            - \"icontains\": Case-insensitive substring match\n    \"\"\"\n\n    SUPPORTED_LOOKUP_EXPR = frozenset({\"\", \"!\", \"gt\", \"lt\", \"gte\", \"lte\", \"in\", \"contains\", \"icontains\"})\n</code></pre>"},{"location":"api/map/","title":"Map","text":""},{"location":"api/map/#lumi_filter.map","title":"<code>lumi_filter.map</code>","text":"<p>Field mapping configurations for different data sources.</p> <p>This module provides mapping configurations that automatically map different data source field types (Peewee ORM fields, Python types) to appropriate filter field classes.</p> <p>The mappings enable automatic field type detection and conversion for seamless integration with various data sources.</p> Available Mappings <p>PEEWEE_FIELD_MAP: Dictionary mapping Peewee ORM field types to filter fields PYTHON_TYPE_MAP: Dictionary mapping Python built-in types to filter fields pw_filter_mapping: ClassHierarchyMapping instance for Peewee fields pd_filter_mapping: ClassHierarchyMapping instance for Python types</p> Supported Field Types <ul> <li>String fields: CharField, TextField, str -&gt; StrField</li> <li>Integer fields: IntegerField, int -&gt; IntField</li> <li>Decimal fields: DecimalField, decimal.Decimal -&gt; DecimalField</li> <li>Boolean fields: BooleanField, bool -&gt; BooleanField</li> <li>Date fields: DateField, datetime.date -&gt; DateField</li> <li>DateTime fields: DateTimeField, datetime.datetime -&gt; DateTimeField</li> </ul> Example <p>from lumi_filter.map import pw_filter_mapping import peewee field_class = pw_filter_mapping.get(peewee.CharField) print(field_class)  #"},{"location":"api/model/","title":"Model","text":""},{"location":"api/model/#lumi_filter.model","title":"<code>lumi_filter.model</code>","text":"<p>Model classes for filtering and ordering data.</p> <p>This module contains the core model classes that provide a unified interface for filtering and ordering different types of data sources including Peewee ORM queries, Pydantic models, and iterable data structures.</p>"},{"location":"api/model/#lumi_filter.model.MetaModel","title":"<code>MetaModel</code>","text":"<p>Configuration class for model metadata.</p> <p>This class handles the configuration and processing of model metadata, including schema introspection and field mapping for both Peewee and Pydantic models.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <p>The model schema (Peewee or Pydantic model class)</p> <code>None</code> <code>fields</code> <code>list</code> <p>List of specific fields to include</p> <code>None</code> Features <ul> <li>Automatic field detection from Peewee and Pydantic models</li> <li>Nested Pydantic model support with dot notation</li> <li>Field filtering based on specified field list</li> <li>Intelligent field type mapping via ClassHierarchyMapping</li> </ul> Source code in <code>lumi_filter/model.py</code> <pre><code>class MetaModel:\n    \"\"\"Configuration class for model metadata.\n\n    This class handles the configuration and processing of model metadata,\n    including schema introspection and field mapping for both Peewee and\n    Pydantic models.\n\n    Args:\n        schema: The model schema (Peewee or Pydantic model class)\n        fields (list, optional): List of specific fields to include\n\n    Features:\n        - Automatic field detection from Peewee and Pydantic models\n        - Nested Pydantic model support with dot notation\n        - Field filtering based on specified field list\n        - Intelligent field type mapping via ClassHierarchyMapping\n    \"\"\"\n\n    def __init__(self, schema=None, fields=None):\n        self.schema = schema\n        self.fields = fields or []\n\n    def get_filter_fields(self):\n        \"\"\"Generate filter fields from schema and extra fields.\n\n        Returns:\n            dict: Dictionary mapping field names to filter field instances\n        \"\"\"\n        ret = {}\n\n        if self.schema is not None:\n            if self._is_peewee_model(self.schema):\n                ret.update(self._process_peewee_fields())\n            elif self._is_pydantic_model(self.schema):\n                ret.update(self._process_pydantic_fields())\n\n        return ret\n\n    def _is_peewee_model(self, schema):\n        \"\"\"Check if schema is a Peewee model.\n\n        Args:\n            schema: The schema to check\n\n        Returns:\n            bool: True if schema is a Peewee model class\n        \"\"\"\n        return isinstance(schema, type) and issubclass(schema, peewee.Model)\n\n    def _is_pydantic_model(self, schema):\n        \"\"\"Check if schema is a Pydantic model.\n\n        Args:\n            schema: The schema to check\n\n        Returns:\n            bool: True if schema is a Pydantic model class\n        \"\"\"\n        return isinstance(schema, type) and issubclass(schema, pydantic.BaseModel)\n\n    def _process_peewee_fields(self):\n        \"\"\"Process Peewee model fields into filter fields.\n\n        Returns:\n            dict: Dictionary mapping field names to filter field instances\n        \"\"\"\n        ret = {}\n        for attr_name, pw_field in self.schema._meta.fields.items():\n            if self.fields and attr_name not in self.fields:\n                continue\n\n            filter_field_class = pw_filter_mapping.get(pw_field.__class__, FilterField)\n            ret[attr_name] = filter_field_class(source=pw_field)\n        return ret\n\n    def _process_pydantic_fields(self):\n        \"\"\"Process Pydantic model fields into filter fields with nested support.\n\n        Returns:\n            dict: Dictionary mapping field names to filter field instances\n        \"\"\"\n        ret = {}\n        stack = [(self.schema.model_fields, \"\")]\n\n        while stack:\n            model_fields, key_prefix = stack.pop()\n            for key, pydantic_field in model_fields.items():\n                new_key = f\"{key_prefix}.{key}\" if key_prefix else key\n\n                if self._is_nested_pydantic_model(pydantic_field):\n                    stack.append(\n                        (\n                            pydantic_field.annotation.model_fields,\n                            new_key,\n                        )\n                    )\n                else:\n                    if self.fields and new_key not in self.fields:\n                        continue\n\n                    filter_field_class = pd_filter_mapping.get(pydantic_field.annotation, FilterField)\n                    field_name = new_key.replace(\".\", \"_\")\n                    ret[field_name] = filter_field_class(request_arg_name=new_key, source=new_key)\n        return ret\n\n    def _is_nested_pydantic_model(self, pydantic_field):\n        \"\"\"Check if a Pydantic field is a nested model.\n\n        Args:\n            pydantic_field: The Pydantic field to check\n\n        Returns:\n            bool: True if field represents a nested Pydantic model\n        \"\"\"\n        return isinstance(pydantic_field.annotation, type) and issubclass(pydantic_field.annotation, pydantic.BaseModel)\n</code></pre>"},{"location":"api/model/#lumi_filter.model.MetaModel.get_filter_fields","title":"<code>get_filter_fields()</code>","text":"<p>Generate filter fields from schema and extra fields.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary mapping field names to filter field instances</p> Source code in <code>lumi_filter/model.py</code> <pre><code>def get_filter_fields(self):\n    \"\"\"Generate filter fields from schema and extra fields.\n\n    Returns:\n        dict: Dictionary mapping field names to filter field instances\n    \"\"\"\n    ret = {}\n\n    if self.schema is not None:\n        if self._is_peewee_model(self.schema):\n            ret.update(self._process_peewee_fields())\n        elif self._is_pydantic_model(self.schema):\n            ret.update(self._process_pydantic_fields())\n\n    return ret\n</code></pre>"},{"location":"api/model/#lumi_filter.model.Model","title":"<code>Model</code>","text":"<p>Base model class for filtering and ordering data.</p> <p>This class provides a unified interface for applying filters and ordering to different types of data sources including Peewee ORM queries, Pydantic models, and iterable data structures.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>The data to filter and order</p> required <code>request_args</code> <code>dict</code> <p>Dictionary of filter and ordering parameters</p> required Source code in <code>lumi_filter/model.py</code> <pre><code>class Model(metaclass=ModelMeta):\n    \"\"\"Base model class for filtering and ordering data.\n\n    This class provides a unified interface for applying filters and ordering\n    to different types of data sources including Peewee ORM queries,\n    Pydantic models, and iterable data structures.\n\n    Args:\n        data: The data to filter and order\n        request_args (dict): Dictionary of filter and ordering parameters\n    \"\"\"\n\n    def __init__(self, data, request_args):\n        self.data = data\n        self.request_args = request_args\n\n    @classmethod\n    def cls_filter(cls, data, request_args):\n        \"\"\"Apply filters to data based on request arguments.\n\n        Args:\n            data: The data to filter\n            request_args (dict): Dictionary of filter parameters\n\n        Returns:\n            Filtered data\n        \"\"\"\n        backend = cls._get_backend(data)\n\n        for req_field_name, req_value in request_args.items():\n            field_info = cls.__supported_query_key_field_dict__.get(req_field_name)\n            if not field_info:\n                continue\n\n            field = field_info[\"field\"]\n            lookup_expr = field_info[\"lookup_expr\"]\n\n            parsed_value, is_valid = field.parse_value(req_value)\n            if not is_valid:\n                continue\n\n            if lookup_expr in [\"in\", \"iin\"]:\n                parsed_value = parsed_value.split(\",\")\n\n            data = backend.filter(data, field.source, parsed_value, lookup_expr)\n\n        return data\n\n    @classmethod\n    def cls_order(cls, data, request_args):\n        \"\"\"Apply ordering to data based on request arguments.\n\n        Args:\n            data: The data to order\n            request_args (dict): Dictionary containing ordering parameters\n\n        Returns:\n            Ordered data\n        \"\"\"\n        ordering = request_args.get(\"ordering\", \"\")\n        if not ordering:\n            return data\n        backend = cls._get_backend(data)\n        available_ordering = []\n        for field_name in ordering.split(\",\"):\n            is_negative = field_name.startswith(\"-\")\n            if is_negative:\n                field_name = field_name[1:]\n            field = cls.__ordering_field_map__.get(field_name)\n            if not field:\n                continue\n            available_ordering.append((field.source, is_negative))\n        return backend.order(data, available_ordering)\n\n    @classmethod\n    def _get_backend(cls, data):\n        \"\"\"Get appropriate backend class for data type.\"\"\"\n        if isinstance(data, peewee.ModelSelect):\n            return PeeweeBackend\n        elif isinstance(data, Iterable):\n            return IterableBackend\n        else:\n            raise TypeError(f\"Unsupported data type: {type(data)}\")\n\n    def filter(self):\n        \"\"\"Apply filters and return self for chaining.\n\n        Returns:\n            Model: Self for method chaining\n        \"\"\"\n        self.data = self.__class__.cls_filter(self.data, self.request_args)\n        return self\n\n    def order(self):\n        \"\"\"Apply ordering and return self for chaining.\n\n        Returns:\n            Model: Self for method chaining\n        \"\"\"\n        self.data = self.__class__.cls_order(self.data, self.request_args)\n        return self\n\n    def result(self):\n        \"\"\"Get the final filtered and ordered data.\n\n        Returns:\n            The processed data\n        \"\"\"\n        return self.data\n</code></pre>"},{"location":"api/model/#lumi_filter.model.Model.cls_filter","title":"<code>cls_filter(data, request_args)</code>  <code>classmethod</code>","text":"<p>Apply filters to data based on request arguments.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>The data to filter</p> required <code>request_args</code> <code>dict</code> <p>Dictionary of filter parameters</p> required <p>Returns:</p> Type Description <p>Filtered data</p> Source code in <code>lumi_filter/model.py</code> <pre><code>@classmethod\ndef cls_filter(cls, data, request_args):\n    \"\"\"Apply filters to data based on request arguments.\n\n    Args:\n        data: The data to filter\n        request_args (dict): Dictionary of filter parameters\n\n    Returns:\n        Filtered data\n    \"\"\"\n    backend = cls._get_backend(data)\n\n    for req_field_name, req_value in request_args.items():\n        field_info = cls.__supported_query_key_field_dict__.get(req_field_name)\n        if not field_info:\n            continue\n\n        field = field_info[\"field\"]\n        lookup_expr = field_info[\"lookup_expr\"]\n\n        parsed_value, is_valid = field.parse_value(req_value)\n        if not is_valid:\n            continue\n\n        if lookup_expr in [\"in\", \"iin\"]:\n            parsed_value = parsed_value.split(\",\")\n\n        data = backend.filter(data, field.source, parsed_value, lookup_expr)\n\n    return data\n</code></pre>"},{"location":"api/model/#lumi_filter.model.Model.cls_order","title":"<code>cls_order(data, request_args)</code>  <code>classmethod</code>","text":"<p>Apply ordering to data based on request arguments.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>The data to order</p> required <code>request_args</code> <code>dict</code> <p>Dictionary containing ordering parameters</p> required <p>Returns:</p> Type Description <p>Ordered data</p> Source code in <code>lumi_filter/model.py</code> <pre><code>@classmethod\ndef cls_order(cls, data, request_args):\n    \"\"\"Apply ordering to data based on request arguments.\n\n    Args:\n        data: The data to order\n        request_args (dict): Dictionary containing ordering parameters\n\n    Returns:\n        Ordered data\n    \"\"\"\n    ordering = request_args.get(\"ordering\", \"\")\n    if not ordering:\n        return data\n    backend = cls._get_backend(data)\n    available_ordering = []\n    for field_name in ordering.split(\",\"):\n        is_negative = field_name.startswith(\"-\")\n        if is_negative:\n            field_name = field_name[1:]\n        field = cls.__ordering_field_map__.get(field_name)\n        if not field:\n            continue\n        available_ordering.append((field.source, is_negative))\n    return backend.order(data, available_ordering)\n</code></pre>"},{"location":"api/model/#lumi_filter.model.Model.filter","title":"<code>filter()</code>","text":"<p>Apply filters and return self for chaining.</p> <p>Returns:</p> Name Type Description <code>Model</code> <p>Self for method chaining</p> Source code in <code>lumi_filter/model.py</code> <pre><code>def filter(self):\n    \"\"\"Apply filters and return self for chaining.\n\n    Returns:\n        Model: Self for method chaining\n    \"\"\"\n    self.data = self.__class__.cls_filter(self.data, self.request_args)\n    return self\n</code></pre>"},{"location":"api/model/#lumi_filter.model.Model.order","title":"<code>order()</code>","text":"<p>Apply ordering and return self for chaining.</p> <p>Returns:</p> Name Type Description <code>Model</code> <p>Self for method chaining</p> Source code in <code>lumi_filter/model.py</code> <pre><code>def order(self):\n    \"\"\"Apply ordering and return self for chaining.\n\n    Returns:\n        Model: Self for method chaining\n    \"\"\"\n    self.data = self.__class__.cls_order(self.data, self.request_args)\n    return self\n</code></pre>"},{"location":"api/model/#lumi_filter.model.Model.result","title":"<code>result()</code>","text":"<p>Get the final filtered and ordered data.</p> <p>Returns:</p> Type Description <p>The processed data</p> Source code in <code>lumi_filter/model.py</code> <pre><code>def result(self):\n    \"\"\"Get the final filtered and ordered data.\n\n    Returns:\n        The processed data\n    \"\"\"\n    return self.data\n</code></pre>"},{"location":"api/model/#lumi_filter.model.ModelMeta","title":"<code>ModelMeta</code>","text":"<p>               Bases: <code>type</code></p> <p>Metaclass for creating filter models with field validation.</p> <p>This metaclass automatically processes model definitions and creates the necessary internal structures for filtering and validation. It handles schema introspection, field mapping, and validation setup.</p> Source code in <code>lumi_filter/model.py</code> <pre><code>class ModelMeta(type):\n    \"\"\"Metaclass for creating filter models with field validation.\n\n    This metaclass automatically processes model definitions and creates\n    the necessary internal structures for filtering and validation.\n    It handles schema introspection, field mapping, and validation setup.\n    \"\"\"\n\n    def __new__(cls, name, bases, attrs):\n        supported_query_key_field_dict = {}\n        meta_options = cls._extract_meta_options(attrs)\n        meta_model = MetaModel(**meta_options)\n\n        # Merge schema fields with explicit attrs (attrs have priority)\n        attrs = meta_model.get_filter_fields() | attrs\n\n        filter_fields = []\n        filter_field_map = {}\n        source_types = set()\n\n        for field_name, field in attrs.items():\n            if isinstance(field, FilterField):\n                cls._configure_field(field, field_name)\n                cls._validate_field_name(field, field_name)\n                filter_field_map[field_name] = field\n                filter_fields.append(field)  # it should be useful in the future\n                source_types.add(cls._get_source_type(field))\n                field_lookup_mappings = cls._get_lookup_expressions(field)\n                supported_query_key_field_dict.update(field_lookup_mappings)\n\n        cls._validate_source_type_consistency(source_types, name)\n\n        attrs[\"__supported_query_key_field_dict__\"] = supported_query_key_field_dict\n        attrs[\"__ordering_field_map__\"] = filter_field_map\n\n        return super().__new__(cls, name, bases, attrs)\n\n    @staticmethod\n    def _get_lookup_expressions(field):\n        \"\"\"Generate lookup expressions mapping for a field.\"\"\"\n        lookup_mappings = {}\n\n        for lookup_expr in field.SUPPORTED_LOOKUP_EXPR:\n            if lookup_expr == \"\":\n                supported_query_key = field.request_arg_name\n            elif lookup_expr == \"!\":\n                supported_query_key = f\"{field.request_arg_name}{lookup_expr}\"\n            else:\n                supported_query_key = f\"{field.request_arg_name}__{lookup_expr}\"\n\n            lookup_mappings[supported_query_key] = {\n                \"field\": field,\n                \"lookup_expr\": lookup_expr,\n            }\n\n        return lookup_mappings\n\n    @staticmethod\n    def _extract_meta_options(attrs):\n        \"\"\"Extract Meta class options.\"\"\"\n        meta_options = {}\n        meta = attrs.pop(\"Meta\", None)\n        if meta:\n            for k, v in meta.__dict__.items():\n                if not k.startswith(\"_\"):\n                    meta_options[k] = v\n        return meta_options\n\n    @staticmethod\n    def _configure_field(field, field_name):\n        \"\"\"Configure field with default values.\"\"\"\n        if field.request_arg_name is None:\n            field.request_arg_name = field_name\n        if field.source is None:\n            field.source = field_name\n\n    @staticmethod\n    def _validate_field_name(field, field_name):\n        \"\"\"Validate field request_arg_name doesn't contain reserved syntax.\"\"\"\n        if \"__\" in field.request_arg_name:\n            raise ValueError(\n                f\"field.request_arg_name of {field_name} cannot contain '__' \"\n                \"because this syntax is reserved for lookups.\"\n            )\n\n    @staticmethod\n    def _get_source_type(field):\n        \"\"\"Determine the source type of a field.\"\"\"\n        if isinstance(field.source, str):\n            return \"string\"\n        elif isinstance(field.source, peewee.Field):\n            return \"peewee_field\"\n        else:\n            return \"other\"\n\n    @staticmethod\n    def _validate_source_type_consistency(source_types, model_name):\n        \"\"\"Validate that all fields have consistent source types.\"\"\"\n        if len(source_types) &gt; 1:\n            raise ValueError(\n                f\"Model {model_name} has fields with different source types: \"\n                f\"{', '.join(source_types)}. All fields must have the same source type.\"\n            )\n</code></pre>"},{"location":"api/operator/","title":"Operator","text":""},{"location":"api/operator/#lumi_filter.operator","title":"<code>lumi_filter.operator</code>","text":"<p>Generic operators for filtering operations.</p> <p>This module provides generic operator functions for filtering operations that work across different data sources and backends.</p>"},{"location":"api/operator/#lumi_filter.operator.generic_ilike_operator","title":"<code>generic_ilike_operator(left, right)</code>","text":"<p>Case-insensitive contains operator.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <p>The value to search in</p> required <code>right</code> <p>The value to search for</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if right is contained in left (case-insensitive)</p> Source code in <code>lumi_filter/operator.py</code> <pre><code>def generic_ilike_operator(left, right):\n    \"\"\"Case-insensitive contains operator.\n\n    Args:\n        left: The value to search in\n        right: The value to search for\n\n    Returns:\n        bool: True if right is contained in left (case-insensitive)\n    \"\"\"\n    return str(right).lower() in str(left).lower()\n</code></pre>"},{"location":"api/operator/#lumi_filter.operator.generic_in_operator","title":"<code>generic_in_operator(left, right)</code>","text":"<p>Generic membership operator.</p> <p>Checks if left value is a member of right iterable. Falls back to equality check if right is not iterable.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <p>The value to check for membership</p> required <code>right</code> <p>The iterable to check membership in</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if left is in right, otherwise False</p> Source code in <code>lumi_filter/operator.py</code> <pre><code>def generic_in_operator(left, right):\n    \"\"\"Generic membership operator.\n\n    Checks if left value is a member of right iterable.\n    Falls back to equality check if right is not iterable.\n\n    Args:\n        left: The value to check for membership\n        right: The iterable to check membership in\n\n    Returns:\n        bool: True if left is in right, otherwise False\n    \"\"\"\n    try:\n        return left in right\n    except TypeError:\n        # If right isn't iterable, fall back to equality\n        return left == right\n</code></pre>"},{"location":"api/operator/#lumi_filter.operator.generic_is_null_operator","title":"<code>generic_is_null_operator(left, right)</code>","text":"<p>Generic null check operator for iterables.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <p>The value to check for null</p> required <code>right</code> <p>String value ('true' or 'false') indicating null check type</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if null check condition is met</p> Source code in <code>lumi_filter/operator.py</code> <pre><code>def generic_is_null_operator(left, right):\n    \"\"\"Generic null check operator for iterables.\n\n    Args:\n        left: The value to check for null\n        right: String value ('true' or 'false') indicating null check type\n\n    Returns:\n        bool: True if null check condition is met\n    \"\"\"\n    is_null_check = right == \"true\"\n    return (left is None) if is_null_check else (left is not None)\n</code></pre>"},{"location":"api/operator/#lumi_filter.operator.generic_like_operator","title":"<code>generic_like_operator(left, right)</code>","text":"<p>Case-sensitive contains operator.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <p>The value to search in</p> required <code>right</code> <p>The value to search for</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if right is contained in left (case-sensitive)</p> Source code in <code>lumi_filter/operator.py</code> <pre><code>def generic_like_operator(left, right):\n    \"\"\"Case-sensitive contains operator.\n\n    Args:\n        left: The value to search in\n        right: The value to search for\n\n    Returns:\n        bool: True if right is contained in left (case-sensitive)\n    \"\"\"\n    return str(right) in str(left)\n</code></pre>"},{"location":"api/operator/#lumi_filter.operator.is_null_operator","title":"<code>is_null_operator(field, value)</code>","text":"<p>Peewee null check operator.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <p>The Peewee field to check</p> required <code>value</code> <p>String value ('true' or 'false') indicating null check</p> required <p>Returns:</p> Type Description <p>Peewee expression for null check</p> Source code in <code>lumi_filter/operator.py</code> <pre><code>def is_null_operator(field, value):\n    \"\"\"Peewee null check operator.\n\n    Args:\n        field: The Peewee field to check\n        value: String value ('true' or 'false') indicating null check\n\n    Returns:\n        Peewee expression for null check\n    \"\"\"\n    return field.is_null(value == \"true\")\n</code></pre>"},{"location":"api/operator/#lumi_filter.operator.operator_curry","title":"<code>operator_curry(operator_name)</code>","text":"<p>Create a curried operator function for peewee fields.</p> <p>Parameters:</p> Name Type Description Default <code>operator_name</code> <code>str</code> <p>Name of the operator method to curry</p> required <p>Returns:</p> Name Type Description <code>function</code> <p>Curried operator function</p> Source code in <code>lumi_filter/operator.py</code> <pre><code>def operator_curry(operator_name):\n    \"\"\"Create a curried operator function for peewee fields.\n\n    Args:\n        operator_name (str): Name of the operator method to curry\n\n    Returns:\n        function: Curried operator function\n    \"\"\"\n\n    def inner(field, value):\n        return getattr(field, operator_name)(value)\n\n    return inner\n</code></pre>"},{"location":"api/shortcut/","title":"Shortcut","text":""},{"location":"api/shortcut/#lumi_filter.shortcut","title":"<code>lumi_filter.shortcut</code>","text":"<p>Shortcut utilities for automatic model generation and request argument compatibility.</p> <p>This module provides convenience utilities for automatically generating filter models from data sources and handling different request argument formats.</p> <p>Classes:</p> Name Description <code>AutoQueryModel</code> <p>Automatically generates filter models from data structure</p> <p>Functions:</p> Name Description <code>compatible_request_args</code> <p>Converts alternative syntax to standard lookup format</p> Supported Data Sources <ul> <li>Peewee ORM ModelSelect queries</li> <li>Iterable data structures (list of dictionaries)</li> <li>Nested dictionary structures with dot notation support</li> </ul> Alternative Syntax Mappings <ul> <li>== -&gt; (exact match)</li> <li>!= -&gt; ! (not equal)</li> <li> <p>= -&gt; __gte</p> </li> <li>&lt;= -&gt; __lte</li> <li> <p>-&gt; __gt</p> </li> <li>&lt; -&gt; __lt</li> <li>LIKE -&gt; __in (contains)</li> <li>ILIKE -&gt; __iin (case-insensitive contains)</li> </ul>"},{"location":"api/shortcut/#lumi_filter.shortcut.AutoQueryModel","title":"<code>AutoQueryModel</code>","text":"<p>Automatic query model generator.</p> <p>This class automatically generates filter models based on the structure of the provided data source, supporting both Peewee ORM queries and iterable data structures.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>The data source to generate model from</p> required <code>request_args</code> <code>dict</code> <p>Request arguments for filtering</p> required Source code in <code>lumi_filter/shortcut.py</code> <pre><code>class AutoQueryModel:\n    \"\"\"Automatic query model generator.\n\n    This class automatically generates filter models based on the structure\n    of the provided data source, supporting both Peewee ORM queries and\n    iterable data structures.\n\n    Args:\n        data: The data source to generate model from\n        request_args (dict): Request arguments for filtering\n    \"\"\"\n\n    def __new__(cls, data, request_args):\n        cls.data = data\n        cls.request_args = request_args\n        attrs = {}\n        if isinstance(cls.data, peewee.ModelSelect):\n            for node in cls.data.selected_columns:\n                if isinstance(node, peewee.Field):\n                    attrs[node.name] = pw_filter_mapping.get(node.__class__, FilterField)(source=node)\n                elif isinstance(node, peewee.Alias) and isinstance(node.node, peewee.Field):\n                    pw_field = node.node\n                    attrs[node.name] = pw_filter_mapping.get(pw_field.__class__, FilterField)(source=pw_field)\n                else:\n                    logger.warning(\n                        \"Unsupported field type in AutoQuery: %s. Using default FilterField.\",\n                        type(node),\n                    )\n        elif isinstance(cls.data, Iterable):\n            cls.data = list(cls.data)\n            if not cls.data:\n                raise ValueError(\"Data cannot be empty for AutoQuery.\")\n            # Check if first item is a dict\n            if not isinstance(cls.data[0], dict):\n                raise TypeError(\"Unsupported data type for AutoQuery\")\n            stack = [(cls.data[0], \"\")]\n            while stack:\n                current_dict, key_prefix = stack.pop()\n                for key, value in current_dict.items():\n                    new_key = f\"{key_prefix}.{key}\" if key_prefix else key\n                    if isinstance(value, dict):\n                        stack.append((value, new_key))\n                    else:\n                        attrs[new_key.replace(\".\", \"_\")] = pd_filter_mapping.get(type(value), FilterField)(\n                            request_arg_name=new_key, source=new_key\n                        )\n        else:\n            logger.error(\"Unsupported data type for AutoQuery: %s\", type(cls.data))\n            raise TypeError(\"Unsupported data type for AutoQuery\")\n        return type(\"dynamic_filter_model\", (Model,), attrs)(data=data, request_args=request_args)\n</code></pre>"},{"location":"api/shortcut/#lumi_filter.shortcut.compatible_request_args","title":"<code>compatible_request_args(request_args)</code>","text":"<p>Convert request arguments to compatible format.</p> <p>This function converts request arguments from alternative syntax formats to the standard lookup expression format used by the filter system.</p> <p>Parameters:</p> Name Type Description Default <code>request_args</code> <code>dict</code> <p>Dictionary of request arguments in alternative format</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary of converted request arguments</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If unsupported lookup expression is encountered</p> Source code in <code>lumi_filter/shortcut.py</code> <pre><code>def compatible_request_args(request_args):\n    \"\"\"Convert request arguments to compatible format.\n\n    This function converts request arguments from alternative syntax formats\n    to the standard lookup expression format used by the filter system.\n\n    Args:\n        request_args (dict): Dictionary of request arguments in alternative format\n\n    Returns:\n        dict: Dictionary of converted request arguments\n\n    Raises:\n        ValueError: If unsupported lookup expression is encountered\n    \"\"\"\n    ret = {}\n    map = {\n        \"==\": \"\",\n        \"!=\": \"!\",\n        \"&gt;=\": \"gte\",\n        \"&lt;=\": \"lte\",\n        \"&gt;\": \"gt\",\n        \"&lt;\": \"lt\",\n        \"LIKE\": \"in\",\n        \"ILIKE\": \"iin\",\n    }\n    for key, value in request_args.items():\n        key_part, lookup_expr = key.split(\"(\", 1)\n        lookup_expr = lookup_expr[:-1]\n        if lookup_expr not in map:\n            raise ValueError(f\"Unsupported lookup expression: {lookup_expr}\")\n\n        mapped_expr = map[lookup_expr]\n        if mapped_expr == \"!\":\n            ret[f\"{key_part}!\"] = value\n        elif mapped_expr == \"\":\n            ret[key_part] = value\n        elif mapped_expr in [\"in\", \"iin\"]:\n            ret[f\"{key_part}__{mapped_expr}\"] = value[1:-1] if len(value) &gt; 2 else value\n        else:\n            ret[f\"{key_part}__{mapped_expr}\"] = value\n    return ret\n</code></pre>"},{"location":"api/util/","title":"Util","text":""},{"location":"api/util/#lumi_filter.util","title":"<code>lumi_filter.util</code>","text":"<p>Utility classes for enhanced mapping functionality.</p> <p>This module provides utility classes that extend standard mapping behavior to support advanced lookup patterns and inheritance-based resolution.</p> <p>Classes:</p> Name Description <code>ClassHierarchyMapping</code> <p>Mapping that supports class hierarchy lookups via MRO</p> Features <ul> <li>Method Resolution Order (MRO) based lookups</li> <li>Union type support for field type resolution</li> <li>Inheritance-aware field mapping</li> <li>Standard MutableMapping interface compliance</li> </ul>"},{"location":"api/util/#lumi_filter.util.ClassHierarchyMapping","title":"<code>ClassHierarchyMapping</code>","text":"<p>               Bases: <code>MutableMapping</code></p> <p>Mapping that supports class hierarchy lookups via Method Resolution Order.</p> <p>This mapping class enables lookups that traverse the class hierarchy using Python's Method Resolution Order (MRO), allowing for inheritance-based field type resolution.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict</code> <p>Initial mapping data</p> <code>None</code> Source code in <code>lumi_filter/util.py</code> <pre><code>class ClassHierarchyMapping(MutableMapping):\n    \"\"\"Mapping that supports class hierarchy lookups via Method Resolution Order.\n\n    This mapping class enables lookups that traverse the class hierarchy using\n    Python's Method Resolution Order (MRO), allowing for inheritance-based\n    field type resolution.\n\n    Args:\n        mapping (dict, optional): Initial mapping data\n    \"\"\"\n\n    def __init__(self, mapping=None):\n        self.data = dict(mapping) if mapping else {}\n\n    def __getitem__(self, key):\n        if isinstance(key, types.UnionType):\n            keys = get_args(key)\n        else:\n            keys = [key]\n        for key in keys:\n            for cls in inspect.getmro(key):\n                if cls in self.data:\n                    return self.data[cls]\n\n        raise KeyError(key)\n\n    def __setitem__(self, key, value):\n        self.data[key] = value\n\n    def __delitem__(self, key):\n        del self.data[key]\n\n    def __iter__(self):\n        return iter(self.data)\n\n    def __len__(self):\n        return len(self.data)\n\n    def __contains__(self, key):\n        return any(cls in self.data for cls in inspect.getmro(key))\n</code></pre>"}]}